+-------------------------------------------------------+-------------------------------------------------------------------------------------------------+
| C++ 源代码                                          | 执行流程 & 可视化 (输入: n=5, m=4, a={10,20,30,20,40}, b={10,20,50,20}, ...)                    |
+-------------------------------------------------------+-------------------------------------------------------------------------------------------------+
| #include <bits/stdc++.h>                               |                                                                                                 |
| using namespace std;                                  |                                                                                                 |
| const int N = 2e5 + 10;                               |                                                                                                 |
| int n, m, res, a[N], b[N];                            |                                                                                                 |
| vector<int> G1[N], G2[N];                             |                                                                                                 |
|                                                       |                                                                                                 |
| void dfs(int u1, int far1, int u2, int far2, int dep) |                                                                                                 |
| {                                                     |                                                                                                 |
|   res = max(res, dep); // <-----------------------------|------------------------ [ 初始调用: dfs(1, 0, 1, 0, 1) ] ------------------------- |
|                                                       |                                `res = max(0, 1) = 1`                                          |
|   map<int, int> mp;                                   |                                为 G1[1] 的邻居创建一个 map `mp`                               |
|   for (auto v : G1[u1])                               |                                `G1[1]` 的邻居: 2 (颜色 20), 3 (颜色 30)                       |
|   {                                                   |                                `mp = { 20: 2, 30: 3 }`                                        |
|     if (v == far1) continue;                          |                                                                                                 |
|     mp[a[v]] = v; // <---------------------------------|                                                                                                 |
|   }                                                   |                                                                                                 |
|                                                       |                                检查 G2[1] 的邻居: 2 (颜色 20), 4 (颜色 20)                      |
|   for (auto v : G2[u2])                               |                                                                                                 |
|   {                                                   |                                v=2 (颜色 20): 检查 `mp[b[2]=20]`? -> 找到! `mp[20]=2`          |
|     if (v == far2) continue;                          |                                  |                                                                |
|     if (mp[b[v]]) // <---------------------------------|--------------------------------+---> 递归调用: dfs(mp[20]=2, u1=1, v=2, u2=1, dep+1=2)          |
|       dfs(mp[b[v]], u1, v, u2, dep + 1); // <----------|                                                                                                 |
|   }                                                   |                                v=4 (颜色 20): 检查 `mp[b[4]=20]`? -> 找到! `mp[20]=2`          |
| }                                                     |                                  |                                                                |
|                                                       |--------------------------------+---> 递归调用: dfs(mp[20]=2, u1=1, v=4, u2=1, dep+1=2)          |
| int main()                                            |                                                                                                 |
| {                                                     |                                                                                                 |
|   cin >> n >> m;                                      | 输入: n=5, m=4                                                                                 |
|   for (int i = 1; i <= n; i++) cin >> a[i];           | 输入: a = {?, 10, 20, 30, 20, 40}                                                              |
|   for (int i = 1; i <= m; i++) cin >> b[i];           | 输入: b = {?, 10, 20, 50, 20}                                                                 |
|                                                       |                                                                                                 |
|   // 构建 G1 (树 1)                                   | 树 1:        1:10                                                                             |
|   for (int i = 2; i <= n; i++) {                      |               /  \                                                                            |
|     int u, v; cin >> u >> v;                          |            2:20  3:30                                                                          |
|     G1[u].push_back(v); G1[v].push_back(u);           |           /  \                                                                               |
|   }                                                   |         4:20 5:40                                                                             |
|                                                       |                                                                                                 |
|   // 构建 G2 (树 2)                                   | 树 2:        1:10                                                                             |
|   for (int i = 2; i <= m; i++) {                      |               /  \                                                                            |
|     int u, v; cin >> u >> v;                          |            2:20  4:20                                                                          |
|     G2[u].push_back(v); G2[v].push_back(u);           |           /                                                                                  |
|   }                                                   |         3:50                                                                                 |
|                                                       |                                                                                                 |
|   if (a[1] != b[1]) // <-----------------------------| 检查: a[1](10) == b[1](10) ? 是. 继续.                                                  |
|     return cout << 0 << '\n', 0;                      |                                                                                                 |
|                                                       |                                                                                                 |
|   res = 0; // 初始化结果                              | `res = 0`                                                                                       |
|   dfs(1, 0, 1, 0, 1); // <---------------------------| 调用 dfs(1, 0, 1, 0, 1)                                                                         |
|                                                       |   |                                                                                             |
|                                                       |   +---- [ 进入 dfs(2, 1, 2, 1, 2) ] ---------------------------------------------------------+ |
|                                                       |   |       `res = max(1, 2) = 2`                                                                 |
|                                                       |   |       为 G1[2] 的邻居创建一个 map `mp` (排除父节点 1)                                        |
|                                                       |   |       `G1[2]` 的邻居: 4 (颜色 20), 5 (颜色 40)                                         |
|                                                       |   |       `mp = { 20: 4, 40: 5 }`                                                               |
|                                                       |   |       检查 G2[2] 的邻居 (排除父节点 1): 3 (颜色 50)                                        |
|                                                       |   |       v=3 (颜色 50): 检查 `mp[b[3]=50]`? -> 未找到 (返回 0). 没有递归调用.                     |
|                                                       |   +---- [ 退出 dfs(2, 1, 2, 1, 2) ] ----------------------------------------------------------+ |
|                                                       |   |                                                                                             |
|                                                       |   +---- [ 进入 dfs(2, 1, 4, 1, 2) ] ---------------------------------------------------------+ |
|                                                       |   |       `res = max(2, 2) = 2`                                                                 |
|                                                       |   |       为 G1[2] 的邻居创建一个 map `mp` (排除父节点 1)                                        |
|                                                       |   |       `G1[2]` 的邻居: 4 (颜色 20), 5 (颜色 40)                                         |
|                                                       |   |       `mp = { 20: 4, 40: 5 }`                                                               |
|                                                       |   |       检查 G2[4] 的邻居 (排除父节点 1): 无.                                                 |
|                                                       |   +---- [ 退出 dfs(2, 1, 4, 1, 2) ] ----------------------------------------------------------+ |
|                                                       |                                                                                                 |
|   cout << res << '\n'; // <--------------------------| 所有 dfs 调用完成. `res` 是 2. 打印 2.                                                    |
|   return 0;                                           |                                                                                                 |
| }                                                     |                                                                                                 |
+-------------------------------------------------------+-------------------------------------------------------------------------------------------------+