#include <bits/stdc++.h> // 引入万能头文件，包含常用的库

using namespace std;  // 使用标准命名空间
using ll = long long; // 定义 ll 为 long long 的别名，尽管在此题中int足够，但保留原样

int main()
{
    // 优化输入输出流，非必需但在竞赛中常用
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n, m;      // n: 棋盘边长, m: 操作次数
    cin >> n >> m; // 读入 n 和 m

    // 定义二维差分数组 'a'。
    // 大小设为 (n+2) x (n+2) 以方便处理边界情况（特别是 x2+1 和 y2+1 可能达到 n+1）。
    // 初始化为全 0。数组 'a' 用于记录每个操作对棋盘状态变化的“增量”。
    vector<vector<int>> a(n + 2, vector<int>(n + 2, 0));

    // 定义二维前缀和数组 's'。
    // 大小同样设为 (n+2) x (n+2)。
    // 's[i][j]' 将存储从 (1,1) 到 (i,j) 区域内所有差分值的累加和，
    // 这等价于棋子 (i,j) 被翻转的总次数。
    // 使用 long long (ll) 类型，虽然操作次数 m 和差分值本身是 int，
    // 但累加和理论上可能超过 int 范围（尽管在此题逻辑下，实际值不会超过 m，int 足够，但遵循原代码片段类型）。
    vector<vector<ll>> s(n + 2, vector<ll>(n + 2, 0LL));

    // 循环处理 m 次操作
    for (int k = 0; k < m; ++k)
    {                                // 从 0 到 m-1，共 m 次迭代
        int x1, y1, x2, y2;          // 每次操作的左上角 (x1, y1) 和右下角 (x2, y2) 坐标
        cin >> x1 >> y1 >> x2 >> y2; // 读入操作范围

        // 应用二维差分技巧：
        // 在矩形区域的左上角 (x1, y1) 处 +1
        a[x1][y1]++;
        // 在矩形区域右边界的右侧一列 (x1, y2 + 1) 处 -1，以抵消对该列及之后列的影响
        a[x1][y2 + 1]--;
        // 在矩形区域下边界的下方一行 (x2 + 1, y1) 处 -1，以抵消对该行及之后行的影响
        a[x2 + 1][y1]--;
        // 在矩形区域右下角的右下方 (x2 + 1, y2 + 1) 处 +1，
        // 以抵消上面两次 -1 操作在 (x2+1, y2+1) 及之后区域造成的双重减法效应。
        a[x2 + 1][y2 + 1]++;
    }

    // 计算二维前缀和，得到每个位置 (i, j) 的实际翻转次数
    // 遍历棋盘的有效区域 (1 到 n 行, 1 到 n 列)
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= n; ++j)
        {
            // 状态转移方程：
            // s[i][j] = 当前位置的差分值 a[i][j]
            //           + 上方单元格的前缀和 s[i-1][j]
            //           + 左侧单元格的前缀和 s[i][j-1]
            //           - 左上方单元格的前缀和 s[i-1][j-1] (因为被加了两次，需要减去一次)
            // 这个公式计算出 (i,j) 处累积的差分效果，即总翻转次数。
            s[i][j] = a[i][j] + s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
        }
    }

    // 输出最终棋盘状态
    // 再次遍历棋盘的有效区域
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= n; ++j)
        {
            // 棋子的最终颜色取决于其被翻转的总次数 s[i][j] 的奇偶性。
            // 初始为白色 (可视为 0)。
            // 翻转奇数次 -> 黑色 (1)
            // 翻转偶数次 -> 白色 (0)
            // 所以，最终颜色状态为 s[i][j] % 2。
            cout << (s[i][j] % 2) << (j == n ? "" : " "); // 输出 0 或 1，并在同行元素间加空格，行末不加
        }
        cout << "\n"; // 每行结束后换行
    }

    return 0; // 程序正常结束
}
